#
# Code generated by `gkgen`
#

.PHONY: plugin data build

OS := $(shell go env GOOS)

# Environments
-include .env

# Get the value from a key of an yaml file
define get_yaml
$(shell yq -r ".$1" ".config/service.$2.yaml")
endef

# Get the packge version
define get_pkg_version
$(shell go list -m $1 | cut -d ' ' -f 2)
endef

# Service
NAME				= $(call get_yaml,name,base)
VERSION				?= $(call get_yaml,version,base)
DESCRIPTION			= $(call get_yaml,description,base)
README				= $(call get_yaml,readme,base)
ARCH				?= amd64 #arm64

PACKAGE				?= $(call get_yaml,package,base)
BUILD_DIR			?= build

# Git
GIT_BRANCH			= $(shell git rev-parse --abbrev-ref HEAD)
GIT_HASH			= $(shell git rev-parse --short HEAD)

# Build flags
G_FLAGS				?= CGO_ENABLED=1
LD_FLAGS			?= -X $(PACKAGE)/cmd.Branch=$(GIT_BRANCH) \
	-X $(PACKAGE)/cmd.Hash=$(GIT_HASH) \
	-X $(PACKAGE)/cmd.BuildDate=$(shell date +%Y-%m-%d)

D_FLAGS				?= -ldflags="$(LD_FLAGS) \
	-X $(PACKAGE)/cmd.BuildMode=debug"
P_FLAGS				?= -ldflags="-s -w $(LD_FLAGS) \
	-X $(PACKAGE)/cmd.BuildMode=production" \
	-trimpath

# Registry
REGISTRY			?= docker.io
REGISTRY_REPO		?= ezconnect
DOCKERFILE			?= Dockerfile

# Override the image & the helm package names
RELEASE_NAME		= $(NAME)

DEPLOYMENT_KIND		?= $(call get_yaml,deployment.kind,k8s)
HELM_REPO			?= freemind
HELM_NAMESPACE		?= dev

#: list all targets
help:
	@grep -B1 -E "^[a-zA-Z0-9_%-]+:([^\=]|$$)" Makefile \
		| grep -v -- -- \
		| sed 'N;s/\n/###/' \
		| sed -n 's/^#: \(.*\)###\(.*\):.*/\2###\1/p' \
		| column -t -s '###'

#: remove untracked files from the working tree
clean:
#	go clean -cache -testcache -modcache -x
	rm -rf build/

#: format the code
fmt:
	goimports -w .
	go fmt ./... > /dev/null

#: run the go linters
lint:
	golangci-lint run --fix ./...

#: copy '/data/*' to the build dir
data:
	@echo 'copy data'
	@mkdir -p $(BUILD_DIR)/data/configs/
	@cp -rv service/*.yaml $(BUILD_DIR)/data/configs/
	@cp plugin/telegram/*.yaml $(BUILD_DIR)/data/configs/

#: run the main package
run: data
	go build -o $(BUILD_DIR)/$(NAME) $(D_FLAGS) -buildmode plugin \
		-o $(BUILD_DIR)/data/plugins/telegram.so \
		plugin/telegram/telegram.go

	go build -o $(BUILD_DIR)/$(NAME) $(D_FLAGS)
	cd $(BUILD_DIR); ./$(NAME) serve $(args);

#: run the main package then watch for changes
watch:
	-nodemon -e go -i $(BUILD_DIR)/ -x make run --signal SIGTERM

#: automates testing the packages
test:
	go test -failfast -v ./... -cover

#: clean the test cache
test-clean:
	go clean -testcache

#-----------------------------------------------------------------------------
# Plugin
# ----------------------------------------------------------------------------
#: build plugins
plugin:
	GOOS=$* GOARCH=$(ARCH) $(G_FLAGS) go build -buildmode plugin $(P_FLAGS) \
		-o $(BUILD_DIR)/data/plugins/telegram.so \
		plugin/telegram/telegram.go

# -----------------------------------------------------------------------------
# Build
# -----------------------------------------------------------------------------
#: build for the current platform
build: build-$(OS)

#: build for: linux, windows, darwin
build-%:
	@for arch in $(ARCH); do \
		echo "build: $*-$$arch"; \
		filename=$(NAME)-$*-$$arch; \
		if [ "$*" = 'windows' ]; then \
			filename=$$filename.exe; \
		fi; \
		GOOS=$* GOARCH=$$arch $(G_FLAGS) go build -o $(BUILD_DIR)/$$filename $(P_FLAGS); \
		echo "  $(BUILD_DIR)/$$filename"; \
		echo "  $(BUILD_DIR)/$$filename.tar.gz"; \
		tar -C $(BUILD_DIR) -zcvf $(BUILD_DIR)/$$filename-$(VERSION).tar.gz $$filename > /dev/null; \
	done; \

# -----------------------------------------------------------------------------
# OCI
# -----------------------------------------------------------------------------
#: build the image
oci:
	@$(foreach arch,$(ARCH), \
		echo "build: $(RELEASE_NAME):$(VERSION)-$(arch)"; \
		podman build -t $(RELEASE_NAME):$(VERSION)-$(arch) -f $(DOCKERFILE) \
			--arch $(arch) $(args) \
			--build-arg arch=$(arch) \
			--annotation org.opencontainers.image.created="$(shell date -I'seconds')" \
			--annotation org.opencontainers.image.description="$(DESCRIPTION)" \
			--annotation io.artifacthub.package.readme-url="$(README)"; \
	)

#: push an image to a specified location that defined in '.env'
oci-push:
ifdef REGISTRY_USER
	podman login -u $(REGISTRY_USER) -p $(REGISTRY_PWD) $(REGISTRY)
else
	podman login $(REGISTRY)
endif

	-podman manifest rm $(RELEASE_NAME):$(VERSION)
	podman manifest create $(RELEASE_NAME):$(VERSION)

	@$(foreach arch,$(ARCH), \
		echo "push: $(REGISTRY)/$(REGISTRY_REPO)/$(RELEASE_NAME):$(VERSION)-$(arch)"; \
		podman push $(RELEASE_NAME):$(VERSION)-$(arch) \
			$(REGISTRY)/$(REGISTRY_REPO)/$(RELEASE_NAME):$(VERSION)-$(arch); \
		podman manifest add $(RELEASE_NAME):$(VERSION) \
			$(REGISTRY)/$(REGISTRY_REPO)/$(RELEASE_NAME):$(VERSION)-$(arch); \
	)

	@echo "push: $(REGISTRY)/$(REGISTRY_REPO)/$(RELEASE_NAME):$(VERSION)"
	podman manifest push $(RELEASE_NAME):$(VERSION) $(REGISTRY)/$(REGISTRY_REPO)/$(RELEASE_NAME):$(VERSION)

# -----------------------------------------------------------------------------
# Helm
# -----------------------------------------------------------------------------
#: generate the Helm chart
helm:
	gkgen gen --helm $(args)
ifneq ($(NAME),$(RELEASE_NAME))
	sed -i -e 's/name: $(NAME)/name: $(RELEASE_NAME)/' .chart/Chart.yaml
endif
	cp .config/service.k8s.yaml .chart/values.yaml
ifneq ($(wildcard .chart/Chart.lock),)
	rm .chart/Chart.lock
endif
	helm dependency build .chart/
	helm lint .chart/

#: render chart templates locally and write to '.chart/k8s.yaml'
pod: helm
	helm template $(RELEASE_NAME) .chart/ > .chart/k8s.yaml

#: upload chart to the repo that defined in '.env'
package: helm
	helm cm-push .chart/ $(HELM_REPO)

#: install the chart to a remote defined in '.env'
install:
	helm repo update && helm install $(RELEASE_NAME) $(HELM_REPO)/$(RELEASE_NAME) -n $(HELM_NAMESPACE) --version $(VERSION) $(args)

#: upgrade the release to the current version of the chart
upgrade:
	helm repo update && helm upgrade $(RELEASE_NAME) $(HELM_REPO)/$(RELEASE_NAME) -n $(HELM_NAMESPACE) --version $(VERSION) $(args)

#: restart the release
restart:
	kubectl rollout restart $(DEPLOYMENT_KIND)/$(RELEASE_NAME) -n $(HELM_NAMESPACE)

#: patch the relase
patch:
	kubectl set image $(DEPLOYMENT_KIND)/$(RELEASE_NAME) \
		-n $(HELM_NAMESPACE) \
		$(RELEASE_NAME)=$(REGISTRY)/$(REGISTRY_REPO)/$(RELEASE_NAME):$(VERSION)

#: uninstall the release
uninstall:
	helm uninstall $(RELEASE_NAME) -n $(HELM_NAMESPACE)

#: execute the release
exec:
	kubectl exec -it $(DEPLOYMENT_KIND)/$(RELEASE_NAME) -n $(HELM_NAMESPACE) -- sh

#: print the logs for the deployment
logs:
	kubectl logs $(DEPLOYMENT_KIND)/$(RELEASE_NAME) -f -n $(HELM_NAMESPACE) --timestamps

#: stop the release
stop:
	kubectl scale --replicas=0 $(DEPLOYMENT_KIND)/$(RELEASE_NAME) -n $(HELM_NAMESPACE)
